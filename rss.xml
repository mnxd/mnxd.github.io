<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>mnxd&#39;s blog</title>
        <link>http://example.com</link>
        <description></description>
        <language>en</language>
        <pubDate>Thu, 11 Jan 2024 22:18:44 +0800</pubDate>
        <lastBuildDate>Thu, 11 Jan 2024 22:18:44 +0800</lastBuildDate>
        <category>各向异性</category>
        <category>纹理</category>
        <item>
            <guid isPermalink="true">http://example.com/2024/01/11/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2Mesh%E6%9D%90%E8%B4%A8/</guid>
            <title></title>
            <link>http://example.com/2024/01/11/%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2Mesh%E6%9D%90%E8%B4%A8/</link>
            <pubDate>Thu, 11 Jan 2024 22:18:44 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;最终采用方法 4，最简单，合理且对场景的修改最小&lt;/p&gt;
&lt;p&gt;参考下文的实现：&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cuY3h5empkLmNvbS9hcnRpY2xlL3FxXzMwNzIyMzgzLzEwMjUyMDA4OA==&#34;&gt;UE4_ 在游戏中 通过按键或事件 动态修改物体材质_UE4_杨一鸣的博客 - 程序员宅基地_ue4 触碰到的地方变材质 - 程序员宅基地 (cxyzjd.com)&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;方法 1，2：可以从 static mesh 新建蓝图控制，也可以在已有蓝图中添加 static mesh，从而实现。见上文&lt;/p&gt;
&lt;p&gt;方法 3：还可以在 farmland_area_indoor 中，已经存在的 staticmeshactor，可以直接在 actor 上添加蓝图脚本，在 event tick 中添加如下逻辑&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111005217.png]]&lt;br&gt;
![[…/Img/Pasted image 20240111005227.png]]&lt;/p&gt;
&lt;p&gt;方法 4： 最简单的办法，直接在子关卡的 Level Blueprint 中添加逻辑，之前的问题是在关卡蓝图中找不到 static mesh component ，但实际上可以直接在世界大纲视图中选中 static mesh 拖到关卡蓝图中，得到如下节点即可。&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111005243.png]]&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111005248.png]]&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/01/11/Radom%20Function/</guid>
            <title></title>
            <link>http://example.com/2024/01/11/Radom%20Function/</link>
            <pubDate>Thu, 11 Jan 2024 22:18:42 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Wang_hash Radom function&lt;br&gt;
![[…/Img/Pasted image 20240111195749.png]]&lt;/p&gt;
&lt;p&gt;pcg_hash Random function &amp;gt; wang_hash&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111195801.png]]&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucmVlZGJldGEuY29tL2Jsb2cvcXVpY2stYW5kLWVhc3ktZ3B1LXJhbmRvbS1udW1iZXJzLWluLWQzZDExLw==&#34;&gt;https://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cucmVlZGJldGEuY29tL2Jsb2cvaGFzaC1mdW5jdGlvbnMtZm9yLWdwdS1yZW5kZXJpbmcv&#34;&gt;https://www.reedbeta.com/blog/hash-functions-for-gpu-rendering/&lt;/span&gt;&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/01/11/Timer%20And%20Benchmark/</guid>
            <title></title>
            <link>http://example.com/2024/01/11/Timer%20And%20Benchmark/</link>
            <pubDate>Thu, 11 Jan 2024 22:18:19 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;Benchmark 并无确定的完全正确的方法，需要自己评判标准&lt;/p&gt;
&lt;p&gt;可以通过如下方式定义一个 Timer 来查看某个指定代码块的执行时间，但是需要注意以下几点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Debug 模式下编译器会添加许多额外的代码，因此此时的 Timer 计时并不能用作参考，应用 Release 模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Release 会主动对代码进行部分优化，比如会将一些简单的循环直接输出结果等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111195929.png]]&lt;/p&gt;
&lt;p&gt;Visual Benchmarking&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj14bEFINGRiTVZuVSZhbXA7bGlzdD1QTGxyQVRmQk5aOThkdWRuTTQ4eWZHVWxkcUdEMFM0RkZiJmFtcDtpbmRleD04MQ==&#34;&gt;https://www.youtube.com/watch?v=xlAH4dbMVnU&amp;amp;list=PLlrATfBNZ98dudnM48yfGUldqGD0S4FFb&amp;amp;index=81&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;chrome://tracing&lt;/p&gt;
&lt;p&gt;Code:&lt;span class=&#34;exturl&#34; data-url=&#34;aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vVGhlQ2hlcm5vLzMxZjEzNWVlYTZlZTcyOWFiNWYyNmE2OTA4ZWIzYTVlI2ZpbGUtaW5zdHJ1bWVudG9yLWg=&#34;&gt;Instrumentor.h&lt;/span&gt;![[…/Img/Instrumentor.h]]&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/01/11/Structured%20Bindings/</guid>
            <title></title>
            <link>http://example.com/2024/01/11/Structured%20Bindings/</link>
            <pubDate>Thu, 11 Jan 2024 22:18:19 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;在 C++ 中如果某个函数需要多个返回值，一般会采用 tuple 或者 pair 等方式，或者自定一个结构体作为返回值，如下所示&lt;br&gt;
！[[…/Img/Pasted image 20240111200136.png]]&lt;br&gt;
 这里的 get (0) 看起来可读性就比较差，因此，有了 std:: tie.，可以改成如下代码取得所 Create 的 Person 的 name 和 age。也具有一定的可读性&lt;br&gt;
！[[…/Img/Pasted image 20240111200138.png]]&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111200141.png]]&lt;br&gt;
 但是 有了 Structured bindings 之后 可以更简单，代码如下，可以简单的通过一行代码实现，并且具有较强的可读性。&lt;br&gt;
![[…/Img/Pasted image 20240111200201.png]]&lt;/p&gt;
&lt;p&gt;唯一需要注意的是，这个特性只在 C&lt;ins&gt;17 及以上版本支持，要开启的话需要将属性里的 C&lt;/ins&gt; 语言设置为 C++17 以上！[[…/Img/Pasted image 20240111200204.png]]&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/01/11/Anisotropic%20Filtering/</guid>
            <title></title>
            <link>http://example.com/2024/01/11/Anisotropic%20Filtering/</link>
            <category>各向异性</category>
            <category>纹理</category>
            <pubDate>Thu, 11 Jan 2024 22:18:08 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;texture-filter纹理过滤&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#texture-filter纹理过滤&#34;&gt;#&lt;/a&gt; &lt;strong&gt;texture filter（纹理过滤）：&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​	纹理是要贴到三维图形表面的，而如下图所示，三维图形上的 pixel 中心和纹理上的 texel 中心并不一至（pixel 不一定对应 texture 上的采样中心 texel），大小也不一定相同。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://upload-images.jianshu.io/upload_images/3868925-6ec9bca4b9995d38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;点采样纹理贴图模型.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;​	当纹理大于三维图形表面时，导至一个像素被映射到许多纹理像素上；当维理小于三维图形表面时，许多个象素都映射到同一纹理。&lt;br&gt;
​	当这些情况发生时，贴图就会变得模糊或发生错位，马赛克。要解决此类问题，必须通过技术平滑 texel 和 pixel 之间的对应。这种技术就是纹理滤波。&lt;br&gt;
​	不同的过滤模式，计算复杂度不一样，会得到不同的效果。过滤模式由简单到复杂包括：Nearest Point Sampling（最近点采样），Bilinear（双线性过滤）、Trilinear（三线性过滤）、Anisotropic Filtering（各向异性过滤）。&lt;br&gt;
​	本文主要是关于各向异性过滤的课堂报告总结，更多针对各向异性过滤（AF）做介绍。&lt;/p&gt;
&lt;h2 id=&#34;nearest-point-sampling最近点采样&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#nearest-point-sampling最近点采样&#34;&gt;#&lt;/a&gt; &lt;strong&gt;Nearest Point Sampling（最近点采样）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​	如纹理过滤中所示，每个像素的纹理坐标，并不是刚好对应 Texture 上的一个采样点 texel，为了解决这个问题，可以采用最近点采样方法。&lt;/p&gt;
&lt;p&gt;​	当纹理的大小与贴图的三维图形的大小差不多时，这种方法非常有效和快捷。如果大小不同，纹理就需要进行放大或缩小，这样，结果就会变得矮胖、变形或模糊&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://upload-images.jianshu.io/upload_images/3868925-f60c4de20ed7b1a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;点采样与双线性.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;bilinear双线性过滤&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#bilinear双线性过滤&#34;&gt;#&lt;/a&gt; &lt;strong&gt;Bilinear（双线性过滤）&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;​	双线性过滤以 pixel 对应的纹理坐标为中心，采该纹理坐标周围 4 个 texel 的像素，再取平均，以平均值作为采样值。&lt;/p&gt;
&lt;p&gt;​	双线性过滤像素之间的过渡更加平滑，但是它只作用于一个 MipMap Level, 它选取 texel 和 pixel 之间大小最接近的那一层 MipMap 进行采样。当和 pixel 大小匹配的 texel 大小在两层 Mipmap level 之间时，双线性过滤在有些情况效果就不太好。于是就有了三线性过滤。&lt;/p&gt;
&lt;h2 id=&#34;trilinear三线性过滤&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#trilinear三线性过滤&#34;&gt;#&lt;/a&gt; Trilinear（三线性过滤）&lt;/h2&gt;
&lt;p&gt;三线性过滤以双线性过滤为基础。会对 pixel 大小与 texel 大小最接近的两层 Mipmap level 分别进行双线性过滤，然后再对两层得到的结果进生线性插值。&lt;/p&gt;
&lt;p&gt;三线性过滤在一般情况下效果非常理想了。但是到目前为止，我们均是假设是 texture 投射到屏幕空间是各向同性的。但是当各向异性的情况时，效果仍然不理想，于是产生了 Anisotropic Filtering（各向异性过滤）。&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://upload-images.jianshu.io/upload_images/3868925-cfd5bd2244b1c2fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;双线性与三线性.png&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;anisotropic各向异性&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#anisotropic各向异性&#34;&gt;#&lt;/a&gt; Anisotropic（各向异性） ：&lt;/h2&gt;
&lt;p&gt;​	The physical or chemical properties of all or part of an object that vary with direction.&lt;/p&gt;
&lt;h2 id=&#34;anisotropic-filtering各向异性过滤&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#anisotropic-filtering各向异性过滤&#34;&gt;#&lt;/a&gt; Anisotropic Filtering（各向异性过滤）：&lt;/h2&gt;
&lt;p&gt;​	A general texture quality enhancement technique that affects the appearance of textures in certain viewing angles.&lt;/p&gt;
&lt;p&gt;​	各向异性本身是指物体的部分或者全部的物理或化学性质会随着方向的不同而有所变化的特性。而在图形学（纹理）中，我们认为，当所要贴图的像素点与屏幕成一定夹角时则为各向异性，否则为各向同性。也可以这样理解，当一个 texture 贴到三维表面上从 Camera 看来没有变形，投射到屏幕空间中后 U 方向和 V 方向比例仍然是一样的，便可以理解成各向同性。反之则认为是各向异性。如下图机场道路所示，&lt;/p&gt;
&lt;p&gt;&lt;img data-src=&#34;https://upload-images.jianshu.io/upload_images/3868925-566ac43af829efc8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&#34; alt=&#34;三线性与各向异性对比.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;可以近似的将道路尽头远处看作向屏幕远处的延申，亦即与屏幕成一定的夹角，此时则为各向异性，纹理贴图时远处的像素点 piexl 与屏幕成一定夹角，可以明显得见道路远处的像素细节较差，纹理整体较为模糊。这是由于线性过滤（双线性与三线性）纹理贴图方式本身的缺陷所导致的。&lt;br&gt;
​	而各向异性过滤把纹理与屏幕空间的角度这个因素考虑时去。简单地说，它会考滤一个 pixel (x:y=1:1) 对应到纹理空间中在 u 和 v 方向上 u 和 v 的比例关系，当 u: v 不是 1:1 时，将会按比例在各方向上采样不同数量的点来计算最终的结果 (这时采样就有可能是长方形区域)。&lt;br&gt;
​	注：事实上各向异性过滤具体还是由硬件实现，这里所讲的还是他的采样方法。各向异性过滤本身相对于双线性与三线性来说并非相互独立的关系，各向异性过滤是在线性过滤的基础上。对采样方法的一种改进。&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2024/01/11/STD%20Optional%20And%20STD%20Variant%20And%20STD%20Any/</guid>
            <title></title>
            <link>http://example.com/2024/01/11/STD%20Optional%20And%20STD%20Variant%20And%20STD%20Any/</link>
            <pubDate>Thu, 11 Jan 2024 22:16:45 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;在做一些类似文件读取类的工作时，可能需要判断文件是否成功被读取，并获得所读取到的值，常见实现如下：&lt;/p&gt;
&lt;p&gt;但是实际上，data 等于空字符串的情况也不止一种，可能是文件读取失败，也可能是文件本身就没有内容&lt;br&gt;
！[[…/Img/Pasted image 20240111193828.png]]&lt;/p&gt;
&lt;p&gt;此时为了判断文件读取状态，也许会新增一个 bool 变量如下&lt;br&gt;
！[[…/Img/Pasted image 20240111193842.png]]&lt;/p&gt;
&lt;h1 id=&#34;std-optional&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#std-optional&#34;&gt;#&lt;/a&gt; std ::optional&lt;/h1&gt;
&lt;p&gt;但是这样代码看起来有些冗余，此时可以用到 std:: optional 如下&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111193855.png]]&lt;/p&gt;
&lt;p&gt;在此基础上，某些情况时我们并不是一定要从这个文件中读取，也可以直接给它默认值，这个时候可以使用.value_or () 如下，此时可以看到，在没有成功读取 data 文件数据时，将赋予了默认值，并打印出日志告知没有成功打开文件。&lt;br&gt;
![[…/Img/Pasted image 20240111193906.png]]&lt;/p&gt;
&lt;h1 id=&#34;stdvariant&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#stdvariant&#34;&gt;#&lt;/a&gt; std::variant&lt;/h1&gt;
&lt;p&gt;但是，其实在此基础上还有进一步优化空间，就是 std::Variant，这个特性使得我们可以在一个变量里储存多种类型的数据，它的使用方法如下。&lt;/p&gt;
&lt;p&gt;这里其实可以将整个 std::variant 理解为一个被指定为可能是 string 也可能是 int 的变量。&lt;/p&gt;
&lt;p&gt;如果我们赋值为 string，则可以通过 string 类型读取，如果赋值为 int 则可以通过 int 类型读取&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111193918.png]]&lt;/p&gt;
&lt;p&gt;然后在此基础上，我们可以将前面 optional 的代码改成如下，通过 ErrorCode 来进行更多的状态判断&lt;/p&gt;
&lt;p&gt;![[…/Img/Pasted image 20240111193931.png]]&lt;/p&gt;
&lt;h1 id=&#34;stdany&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#stdany&#34;&gt;#&lt;/a&gt; std::any&lt;/h1&gt;
&lt;p&gt;相比较于 std:: variant，std:: any 更加简单。可以直接存储任何类型的数据，但同样 std:: variant 要求你在使用时列举出所有可能的类型，这样更能保证类型安全，variant 是一个类型安全的 union，而 Any，阅读源码可以看出，在类型较少时，它是和 variant 一样的通过 union 的存储方式，而当类型更多时，则是 void* 的存储，以便动态分配内存&lt;br&gt;
！[[…/Img/Pasted image 20240111193940.png]]&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">http://example.com/2023/07/12/Event%20Dispatchers/</guid>
            <title></title>
            <link>http://example.com/2023/07/12/Event%20Dispatchers/</link>
            <pubDate>Wed, 12 Jul 2023 23:37:59 +0800</pubDate>
            <description><![CDATA[ &lt;p&gt;事件分发器是一种常用的设计模式，它可以将事件的发送者和接收者解耦，从而提高代码的可维护性和可扩展性。在 UE4 中，事件分发器是一种在不同对象或蓝图之间通信的方式。它们允许一个对象广播事件，任何已注册以侦听该事件的其他对象都将收到它。事件分发器通常用于处理游戏中的各种事件，比如玩家输入、碰撞检测、动画播放等等。&lt;/p&gt;
&lt;p&gt;UE4 中的事件分发器通常由两部分组成：事件发送者和事件接收者。事件发送者通常是一个 Actor 或者 Component，它负责发送事件。事件接收者通常是一个 Actor 或者 Component，它负责接收事件并做出相应的响应。&lt;/p&gt;
&lt;p&gt;UE4 中的事件分发器通常使用委托（Delegate）来实现。委托是一种特殊的函数指针，它可以指向一个或多个函数，并且可以在运行时动态添加或删除函数。在 UE4 中，委托通常用于事件的注册和响应。&lt;/p&gt;
&lt;p&gt;下面是一个简单的示例，演示了如何在 UE4 中使用事件分发器：&lt;/p&gt;
&lt;p&gt;首先，在事件发送者中定义一个委托：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;DECLARE_EVENT(FMyEventSender, FMyEvent);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;然后，在事件发送者中定义一个事件：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;FMyEvent MyEvent;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;接着，在事件发送者中定义一个函数，用于触发事件：&lt;/p&gt;
&lt;p MyEvent.Broadcast();=&#34;&#34;&gt;void FMyEventSender::TriggerEvent()&lt;/p&gt;
&lt;p&gt;在这个函数中，我们调用了 MyEvent.Broadcast () 函数，这个函数会触发事件，并将事件发送给所有注册了这个事件的委托。&lt;/p&gt;
&lt;p&gt;最后，在事件接收者中注册事件：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;MyEventSender-&amp;gt;MyEvent.AddUObject(this, &amp;amp;AFoo::OnMyEvent);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个函数中，我们调用了 MyEventSender-&amp;gt;MyEvent.AddUObject () 函数，这个函数会将当前对象的 OnMyEvent () 函数注册到 MyEvent 事件中。当事件触发时，所有注册了这个事件的委托都会被调用。在事件接收者中，我们可以定义一个函数，用于响应事件：&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;void AFoo::OnMyEvent() &amp;#123; // Do something &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在这个函数中，我们可以编写相应的逻辑，用于处理事件。&lt;/p&gt;
&lt;p&gt;总的来说，UE4 中的事件分发器是一种非常强大的工具，它可以帮助我们实现复杂的游戏逻辑，并且提高代码的可维护性和可扩展性&lt;/p&gt;
&lt;figure class=&#34;highlight plaintext&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;// 在您的头文件中： DECLARE_EVENT(AMyActor, FMyEvent); FMyEvent MyEvent; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 在您的源文件中： void AMyActor::SomeFunction() &amp;#123; // 广播事件 MyEvent.Broadcast(); &amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 在另一个想要侦听事件的对象中：&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void AMyOtherActor::BeginPlay()&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#123; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	AMyActor* MyActor = ...;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	// 获取将广播事件的参考 &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;	MyActor-&amp;gt;MyEvent.AddDynamic(this, &amp;amp;AMyOtherActor::OnMyEvent);&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125; &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;void AMyOtherActor::OnMyEvent() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;// 当事件广播时，将调用此函数 &lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
 ]]></description>
        </item>
    </channel>
</rss>
