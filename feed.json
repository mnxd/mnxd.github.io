{
    "version": "https://jsonfeed.org/version/1",
    "title": "mnxd's blog",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2023/07/12/Test/",
            "url": "http://example.com/2023/07/12/Test/",
            "title": "",
            "date_published": "2023-07-12T15:37:59.398Z",
            "content_html": "<p>在做一些类似文件读取类的工作时，可能需要判断文件是否成功被读取，并获得所读取到的值，常见实现如下：<br>\n但是实际上，data 等于空字符串的情况也不止一种，可能是文件读取失败，也可能是文件本身就没有内容<br>\n<img data-src=\"image-2.png\" alt=\"Alt text\"></p>\n<p>此时为了判断文件读取状态，也许会新增一个 bool 变量 如下</p>\n<p><img data-src=\"image-3.png\" alt=\"Alt text\"></p>\n<h2 id=\"stdoptional\"><a class=\"markdownIt-Anchor\" href=\"#stdoptional\">#</a> std::optional</h2>\n<p>但是这样代码看起来有些冗余，此时可以用到 std::optional 如下</p>\n<p><img data-src=\"image-4.png\" alt=\"Alt text\"></p>\n<p>在此基础上，某些情况时我们并不是一定要从这个文件中读取，也可以直接给它默认值，这个时候可以使用.value_or () 如下，此时可以看到，在没有成功读取 data 文件数据时，将赋予了默认值，并打印出日志告知没有成功打开文件。</p>\n<p><img data-src=\"image-5.png\" alt=\"Alt text\"></p>\n<h2 id=\"stdvariant\"><a class=\"markdownIt-Anchor\" href=\"#stdvariant\">#</a> std::variant</h2>\n<p>但是，其实在此基础上还有进一步优化空间，就是 std::Variant，这个特性使得我们可以在一个变量里储存多种类型的数据，它的使用方法如下。<br>\n这里其实可以将整个 std::variant 理解为一个被指定为可能是 string 也可能是 int 的变量。如果我们赋值为 string，则可以通过 string 类型读取，如果赋值为 int 则可以通过 int 类型读取</p>\n<p><img data-src=\"image-6.png\" alt=\"Alt text\"></p>\n<p>然后在此基础上，我们可以将前面 optional 的代码改成如下，通过 ErrorCode 来进行更多的状态判断</p>\n<p><img data-src=\"image-7.png\" alt=\"Alt text\"></p>\n<h2 id=\"stdany\"><a class=\"markdownIt-Anchor\" href=\"#stdany\">#</a> std::any</h2>\n<p>相比较于 std::variant，std::any 更加简单。可以直接存储任何类型的数据，但同样 std::variant 要求你在使用时列举出所有可能的类型，这样更能保证类型安全，variant 是一个类型安全的 union，而 Any，阅读源码可以看出，在类型较少时，它是和 variant 一样的通过 union 的存储方式，而当类型更多时，则是 void* 的存储，以便动态分配内存</p>\n<p><img data-src=\"image.png\" alt=\"Alt text\"></p>\n",
            "tags": []
        }
    ]
}